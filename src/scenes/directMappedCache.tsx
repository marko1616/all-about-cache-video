import { Code, Layout, makeScene2D, Rect } from "@motion-canvas/2d";
import { all, delay, waitFor } from "@motion-canvas/core";
import { createRef, ThreadGenerator } from "@motion-canvas/core";

import { verticalOverlayTransition } from "../transitions/OverlayTransition";
import { DataBus } from "../components/DataBus";
import { CpuMaster } from "../components/CpuMaster";
import { MemSlave } from "../components/MemSlave";
import { Cache } from "../components/cache/Cache";
import { hexToHsl } from "../utils/ColorUtils";

/**
 * Clamps a number into [min, max].
 */
function clamp(v: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, v));
}

/**
 * Builds a palette of distinct set colors by boosting the base saturation and
 * rotating hue evenly across the full 360Â° color wheel.
 */
function buildSetColors(
  baseHex: string,
  numSets: number,
  satBoost: number = 18,
): string[] {
  const [baseHue, baseSat, baseLight] = hexToHsl(baseHex);
  const sat = clamp(baseSat + satBoost, 0, 100);

  return Array.from({ length: numSets }, (_, i) => {
    const hue = (baseHue + (i * 360) / numSets) % 360;
    return `hsl(${hue}, ${sat}%, ${baseLight}%)`;
  });
}

/**
 * Computes the cache set index for a byte address (correct design).
 * Address layout: | Tag | Set | Offset |
 */
function getSetIndex(
  addr: number,
  offsetBits: number,
  setBits: number,
): number {
  const setMask = (1 << setBits) - 1;
  return (addr >> offsetBits) & setMask;
}

/**
 * Computes the cache set index for a byte address (WRONG design).
 * Address layout: | Set | Tag | Offset |
 * This puts set bits at the highest position, which is a poor cache design
 * because sequential addresses will all map to the same set.
 */
function getSetIndexWrong(
  addr: number,
  offsetBits: number,
  setBits: number,
  addrBits: number = 8,
): number {
  const setMask = (1 << setBits) - 1;
  // Set bits are at the highest position: shift right by (addrBits - setBits)
  return (addr >> (addrBits - setBits)) & setMask;
}

/**
 * Animates memory row coloring so that all addresses mapping to the same set share the same color.
 * The palette is generated by boosting saturation from the given base color and rotating hue
 * across the full wheel.
 *
 * Uses CORRECT address layout: | Tag | Set | Offset |
 */
function* colorizeMemoryBySet(
  mem: MemSlave,
  offsetBits: number,
  setBits: number,
  baseHex: string,
  fillDuration: number = 0.25,
): ThreadGenerator {
  const numSets = 1 << setBits;
  const setColors = buildSetColors(baseHex, numSets);

  const tasks: ThreadGenerator[] = [];
  for (let addr = 0; addr < 256; addr++) {
    const set = getSetIndex(addr, offsetBits, setBits);
    tasks.push(mem.setAddressColor(addr, setColors[set], fillDuration));
  }
  yield* all(...tasks);
}

/**
 * Animates memory row coloring using the WRONG cache design where Set bits
 * are placed at the highest position instead of after the offset.
 *
 * Uses WRONG address layout: | Set | Tag | Offset |
 *
 * This demonstrates why this is a poor design:
 * - Sequential memory addresses all map to the same set
 * - Large contiguous blocks of memory share the same color
 * - Poor cache utilization for typical access patterns (spatial locality)
 */
function* colorizeMemoryBySetWrong(
  mem: MemSlave,
  offsetBits: number,
  setBits: number,
  baseHex: string,
  fillDuration: number = 0.25,
  addrBits: number = 8,
): ThreadGenerator {
  const numSets = 1 << setBits;
  const setColors = buildSetColors(baseHex, numSets);

  const tasks: ThreadGenerator[] = [];
  for (let addr = 0; addr < 256; addr++) {
    const set = getSetIndexWrong(addr, offsetBits, setBits, addrBits);
    tasks.push(mem.setAddressColor(addr, setColors[set], fillDuration));
  }
  yield* all(...tasks);
}

export default makeScene2D(function* (view) {
  const cpu = createRef<CpuMaster>();
  const bus = createRef<DataBus>();
  const mem = createRef<MemSlave>();
  const cache = createRef<Cache>();
  const bus2 = createRef<DataBus>();

  const mainContainer = createRef<Layout>();
  const code = createRef<Code>();

  const cacheContainer = createRef<Rect>();
  const cacheOverlay = createRef<Rect>();

  view.add(
    <>
      <Layout
        layout
        ref={mainContainer}
        direction={"column"}
        alignItems={"center"}
        gap={0}
      >
        <Code
          ref={code}
          code={""}
          fontSize={0}
          fontFamily={"JetBrains Mono"}
        ></Code>
        <Layout layout alignItems={"center"} gap={0}>
          <CpuMaster
            ref={cpu}
            bus={bus}
            width={600}
            height={600}
            zIndex={1}
            padding={60}
            radius={10}
            backgroundFill={"#DAD2BC"}
            contentFill={"#242424"}
          />
          <DataBus
            ref={bus}
            busWidth={100}
            busHeight={60}
            busGap={40}
            strokeColor={"#DAD2BC"}
            requestLabel="REQ"
            responseLabel="ACK"
          />
          <Rect ref={cacheContainer} width={2040} height={2040}>
            <Layout layout={false}>
              <Cache
                ref={cache}
                bus={bus2}
                offsetBits={1}
                setBits={3}
                numWays={1}
                titlePrefix={""}
                width={600}
                height={600}
                zIndex={1}
                backgroundFill={"#DAD2BC"}
                contentFill={"#242424"}
              />
              <Rect
                ref={cacheOverlay}
                width={2060}
                height={0}
                radius={24}
                fill={"#242424"}
                zIndex={100}
              />
            </Layout>
          </Rect>
          <DataBus
            ref={bus2}
            busWidth={100}
            busHeight={60}
            busGap={40}
            strokeColor={"#DAD2BC"}
            requestLabel="REQ"
            responseLabel="ACK"
          />
          <MemSlave
            ref={mem}
            width={600}
            height={600}
            zIndex={1}
            padding={60}
            radius={10}
            backgroundFill={"#DAD2BC"}
            highlightFill={"#F5F1ED"}
            writeHighlight={"#474747"}
            contentFill={"#242424"}
          />
        </Layout>
      </Layout>
    </>,
  );

  bus().slaveHandler = cache().getHandler();
  bus2().slaveHandler = mem().getHandler();
  cpu().enableCacheLineMode(1);
  cache().setDetailedImmediate(2040, 2040);

  yield* verticalOverlayTransition(
    "Chapter Four - Mapping strategy - Part 1 - Direct Mapped Cache",
    "Mapping strategy",
    "Direct Mapped Cache",
    0.1,
  );

  yield* cpu().writeByte(0x10, 0x1);
  yield* waitFor(1);

  yield* cpu().writeByte(0x12, 0x1);
  yield* waitFor(1);

  yield* all(
    mem().transformDetailed(400, 1600),
    delay(1, bus2().busWidth(300, 1)),
  );

  yield* colorizeMemoryBySet(mem(), 1, 3, "#DAD2BC");

  yield* waitFor(1);

  yield* all(
    cache().animateSwapTagAndSet(),
    colorizeMemoryBySetWrong(mem(), 1, 3, "#DAD2BC"),
  );

  yield* waitFor(1);

  yield* all(
    cache().animateRestoreTagAndSet(),
    colorizeMemoryBySet(mem(), 1, 3, "#DAD2BC"),
  );
});
